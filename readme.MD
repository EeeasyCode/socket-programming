# Socket-Programming

## OS 구조
```
User - Kernel - HW 
```
사용자가 어떤 프로그램을 만들어서 process를 실행하면 해당 process가 실행되기 위해서는 cpu와 같은 하드웨어에 직접 접근하지 않음. <br>
'System call' 이라는 인터페이스를 통해 user mode에서 kernel 모드로 넘어가면서 device driver를 제어하기 시작함. <br>
즉, 응용 프로그램이 하드웨어 자원에 접근하거나 OS가 제공하는 서비스를 이용하려할 때는 system call을 이용해야 하며, 이렇게 함으로써 컴퓨터 자원을 보호할 수 있음. <br>
kernel mode와 hardware mode 사이의 인터페이스는 driver가 담당함. <br>
이때 device driver가 IRQ를 통해 인터럽트를 요청하면서 원하는 장치를 사용하면서 연산을 시작하고 본인의 작업(위의 프로세스)이 끝나면 return함. <br>
<br>
드라이버: 운영 체제와 디바이스가 서로 통신할 수 있는 소프트웨어 구성 요소 <br>
IRQ: 인터럽트 요청 <br>

## File
유저모드 어플리케이션이 커널에 진입할 수 있도록 추상화된 인터페이스가 파일이다. 유저모드에서 커널모드에 진입할 수 있는 유일한 수단이다. 

## Socket 
프로세스가 네트워크 세계로 데이터를 내보내거나 혹은 데이터를 받기 위한 실제적인 창구 역할
프로세스가 데이터를 보내거나 받기 위해서는 반드시 소켓을 열어서 소켓에 데이터를 써내보내거나 소켓으로부터 데이터를 읽어들어야 함.
> 이 말의 뜻은  각 프로세스는 소켓을 통해서 통신을 하게 되는데, 소켓은 간단히 얘기해 ip주소와 포트번호를 갖고 있는 인터페이스라고 생각하면 됩니다. 소켓은 리눅스에서 파일로 다루어지며 프로세스는 이 소켓을 사용할때 파일디스크립터를 통해 사용합니다. 우리는 리눅스 파일 입출력에 대해 배울때 파일디스크립터를 사용했지요? 소켓 역시 파일디스크립터를 이용해서 읽기, 쓰기가 가능합니다.
네, 맞습니다. 한 가지 중요한 사실은 Kernel 요소에 대한 User mode 접근은 모두 장치 '파일'로 이루어진다는 점 입니다. 파일은 관리(생성, 복사, 삭제) 데이터 덩어리로 이해 할 수도 있지만 미디어 장치 및 관리체계(파일 시스템)에 대한 사용성을 제공하는 추상화된 인터페이스로 이해 할 수도 있습니다.

소켓도 마찬가지 입니다. 우리가 파일을 통해 HDD 제품 특성과 H/W구조를 몰라도 Disk 장치를 사용 할 수 있는 것처럼 NIC H/W 특성을 몰라도 Socket이라는 파일을 통해 사용할 수 있는 것입니다.

결과적으로 보면 연관성을 가지고 이해 할 문제가 아닐 수 있습니다. 그렇게 만들어진 것을 있는 그대로 받아 들이는 것이어야 할 수 있습니다. 시스템 프로그래밍을 꼭 공부해보시기 바랍니다. 그러면 제가 왜 소켓을 파일의 일종으로 설명했는지 제대로 이해 할 수 있을 것입니다. 감사합니다.

 

소캣은 프로토컬, IP주소, 포트 넘버로 정의된다.
소켓은 떨어져 있는 두 호스트를 연결해주는 도구로써 인터페이스 역할
데이터를 주고 받을 수 있는 구조체
소켓을 통해 데이터 통로가 만들어집니다.
소켓은 역할에 따라 서버 소켓, 클라이언트 소켓으로 구분됩니다.









### remove ds_store
``` 
find . -name .DS_Store -print0 | xargs -0 git rm -f --ignore-unmatch
```

